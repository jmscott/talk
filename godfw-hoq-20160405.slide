Writing an Interpreter in Go

*John*Scott*
jmscott@setspace.com
https://github.com/jmscott

Unix/Database Consultant
Founder, SetSpace, Inc, 1998-now
Founder, august.{com,net}, Inc, 1998-2006

Capitol One Conference Center
Plano, Texas, USA
April 5, 2016

* Paul Graham - YCombinator
 Your mind is like a compiled program you've lost the source of.
 It works, but you don't know why.

* What is a Compiler?
- program to transform a source language into a target language
- immutable - same input yields same output 
- typically compiled version program in any language runs "fastest", in some sense
- semantics of language NOT determined by compiler

* Examples of Typically Compiled Languages
- go
- c
- java
- YACC compiles Backus-Naur into Go (and many other languages)
- Ken Thompson wrote regular expression compiler
- research into compiling SQL into native code (Oracle, PostgreSQL)

* What is an Interpreter?
- program that directly executes the source program (often text)

.image godfw-hoq-20160405/tao.gif

- bourne shell, awk, javascript, ruby, SQL
- lisp was the first interpreter
- the java command is an interpreter of compiled java class files

* Interpreter Translates Source into Internal Format
.image godfw-hoq-20160405/ast.png
.caption Abstract Syntax Tree (perl5, awk)
- line by line (many unix shells)
- virtual machine instruction (python, ruby, vbasic, java, perl6)
- just in time compilation (java)

* Abstract Syntax Tree
.image godfw-hoq-20160405/ast.png
.caption Query Fragment
  $1 == "INBOUND" and ( $2 ~~ "^10[.]" or $2 ~~ "^192[.]168" )

* What is HOQ?
- toy interpreter to demonstrate famous YACC compiler in Go
- also, hopefully, demonstrates "Communicating Sequential Processes"

Did I bite off more than I can chew?

* Inspired by HOC Calculator in "Unix Programming Environment"
.image godfw-hoq-20160405/upe.jpg
.caption Mighty Fine Book

* HOQ Invocation
- command line program, invoked like
 hoq file.hoq <data.in
- hoq script may invoke unix programs and wait for their exit status
- the `standard`out` and `standard`error` of invoked process are *NOT* redirected

* HOQ is Driven by Standard Input
- consuming input text drives the execution of the hoq script
 tr ',' '\t' quarterly.csv | hoq quarterly.hoq
.caption Terminal
- program ends after reading all lines on standard input

* HOQ Splits Input Into Fields
- input lines `strings.Split()` on tab separated boundaries
 line = strings.TrimRight(line, "\n")
 ...
 fields:   strings.SplitN(line, "\t", 255),
- `$1` is first tab separated field, `$2` is second, ...
- `$0` is current input line

* HOQ is Mostly Declarative
- execution order determined by boolean qualifications
- qualify on patterns in input text
- qualify on process exit status
- easy concurrent execution of a directed acyclic graph

* Hello, World

.code godfw-hoq-20160405/say.hoq 
.caption say.hoq

* Invoke Say
.code godfw-hoq-20160405/say.hoq 
.caption say.hoq

.code godfw-hoq-20160405/say.term 
.caption Terminal

* Good Bye, Cruel World
.code godfw-hoq-20160405/say-bye.hoq 
.caption say-bye.hoq

.code godfw-hoq-20160405/say-bye.term 
.caption Terminal

* Trinity
.code godfw-hoq-20160405/say-trinity.hoq 
.caption say-trinity.hoq

.code godfw-hoq-20160405/say-trinity.term 
.caption Terminal

* Complex Queries in HOQ

* Confluence
- AST is a flow graph!
- Input text and exit codes flow bottom up
- SQL query planners flow tuples bottom up
- Logic Programming Languages (Prolog, Datalog)

* Go Idioms in HOQ
- close is cheap broadcast
- serial functions easy to make concurrent
- null method pointer allows elegant recursive termination
- simulataneous read from many inputs
- fanin/fanout

* Philip Wadler
Theory is your warm fuzzy friend.

* What is "Communicationg Sequential Process"?
- Book "Communicating Sequential Process"
  third-most cited computer science reference of all time according to Citeseer 

* Squinting at Power Series by Doug McIlroy
.image godfw-hoq-20160405/expx.png
.image godfw-hoq-20160405/expx1.png
Rewrites calculus Taylor series in CSP!

* What is Go YACC?
- Compiles a Flavor of Backus-Naur Form (BNF) into Go Code
- Orginal Golang Grammar written in YACC
- Domain Specific Languages (chemical reactions, SAT solvers)
- Mutation Coverage

* Backus-Naur Grammar of Backus-Naur
 Production  = name "=" [ Expression ] "." .
 Expression  = Alternative { "|" Alternative } .
 Alternative = Term { Term } .
 Term        = name | token [ "â€¦" token ] | Group | Option | Repetition .
 Group       = "(" Expression ")" .
 Option      = "[" Expression "]" .
 Repetition  = "{" Expression "}" .

* HOQ Backus-Naur, Go Code Stripped
.code godfw-hoq-20160405/hoq.bnf

* YACC Needs a Lexer 
- busts text into stream of integer tokens
- token has a value related to scan
- lexer can be a big switch{}
- lexer easy to write by hand
- token constants defined by YACC (see %token in grammar)
- co-routines invented to write lexers

* Complex Example of HOQ
Tuesday


* HOQ Grammar and Go Code

* Go Files
- hoq.go
- ast.go
- command.go (rename to exec.go)?
- compile.go
- opcode.go
- parser.y
- rummy.go
- tsort.go

* Opcodes and Machine Model
- const_string, const_bool, const_uint8
- to_string_uint8, to_string_bool
- dollar, dollar0
- string_rel2, uint8_rel2, bool_rel2
- argv0, argv1, argv
- exec
- fanout_uint8, fanin_uint8

* YACC Resources
.link https://docs.google.com/document/d/1P3BLR31VA8cvLJLfMibSuTdwTuF7WWLux71CYD0eeD8/edit Early GoLang in YACC
.link http://www.amazon.com/Unix-Programming-Environment-Prentice-Hall-Software/dp/013937681X Book 'Unix Programming Environment" by Kernighan and Pike
.link http://heim.ifi.uio.no/inf2270/programmer/historien-om-C.pdf C Written in Yacc
.link https://github.com/golang-samples/yacc Simple Go Calculator
.link https://golang.org/pkg/go/ast/ Go AST Library
.link https://godoc.org/golang.org/x/exp/ebnf EBNF in GoLang

* Lex Resources
.link https://www.youtube.com/watch?v=HxaD_trXwRE Lexer Talk by Rob Pike
.link http://www.colm.net/open-source/ragel/ Ragle is a Lexical Compiler
.link http://www-cs-students.stanford.edu/~blynn/nex/ Nex (New Lex)

* CSP Resources
.link http://research.swtch.com/power
